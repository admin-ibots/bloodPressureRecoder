#include <Arduino.h>
#include <WiFi.h>
#include <HTTPClient.h>
#include <WiFiClientSecure.h>
#include "../secretes/bpr_webhooks.h"

// define WIFI: HOME or OFFICE
#define  WIFI HOME
#include "../secretes/wifi_credentials.h"

// const String url = N8N_BPR_CLOUD_FLARE_HTTPS_WEBHOOK;
const String url = GAS_BPR_HTTPS_WEBHOOK;

unsigned long startMs;
unsigned long duration;

void setup() {
    Serial.begin(115200);
    WiFi.setSleep(false);
    WiFi.begin(ssid, password);
    while (WiFi.status() != WL_CONNECTED) { delay(500); Serial.print("."); }
    Serial.println("\n--- WiFi Connected ---");   
}

void call_n8n() {
    // 監控記憶體，HTTPS 握手前至少需要 > 50000 比較保險
    Serial.printf("\n[Memory] Free Heap: %d\n", ESP.getFreeHeap());

    WiFiClientSecure client; // 改用 Stack 分配，函數結束後會自動釋放
    client.setInsecure();    // 跳過憑證驗證

    HTTPClient https;
    Serial.println("[HTTPS] 正在建立加密連線...");

    

    // 增加超時到 20 秒，因為 SSL 握手在網路不穩時會很慢
    if (https.begin(client, url)) {
        https.setTimeout(20000); 
        https.addHeader("Connection", "close");

        https.setFollowRedirects(HTTPC_STRICT_FOLLOW_REDIRECTS); // 加入這行！

        int httpCode = https.GET();

        if (httpCode > 0) {
            Serial.printf("[HTTPS] 成功! 代碼: %d\n", httpCode);
            Serial.println("回應內容: " + https.getString());
        } else {
            // 如果這裏報 -1，代表 SSL 握手失敗
            Serial.printf("[HTTPS] 失敗! 錯誤碼: %d (%s)\n", 
                          httpCode, https.errorToString(httpCode).c_str());
        }
        https.end();
    }
    
    // client 會在函數結束時自動清理
}

void loop() {
    if (WiFi.status() == WL_CONNECTED) {
        startMs = millis(); // 記錄開始毫秒數
        call_n8n();
        duration = millis() - startMs; // 計算耗時
        Serial.printf("n8n 耗時: %lu 毫秒\n", duration);
    }
    delay(20000);
}